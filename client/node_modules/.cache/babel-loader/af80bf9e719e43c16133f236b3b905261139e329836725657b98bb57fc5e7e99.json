{"ast":null,"code":"import { hashQueryKey, noop, parseFilterArgs, parseQueryArgs, partialMatchKey, hashQueryKeyByOptions, functionalUpdate } from \"./utils.mjs\";\nimport { QueryCache } from \"./queryCache.mjs\";\nimport { MutationCache } from \"./mutationCache.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.mjs\";\nimport { defaultLogger } from \"./logger.mjs\"; // TYPES\n\n// CLASS\nexport class QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n  isMutating(filters) {\n    return this.mutationCache.findAll({\n      ...filters,\n      fetching: true\n    }).length;\n  }\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, {\n      ...options,\n      manual: true\n    });\n  }\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n      return query.fetch(undefined, {\n        ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n  getQueryCache() {\n    return this.queryCache;\n  }\n  getMutationCache() {\n    return this.mutationCache;\n  }\n  getLogger() {\n    return this.logger;\n  }\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n}","map":{"version":3,"names":["hashQueryKey","noop","parseFilterArgs","parseQueryArgs","partialMatchKey","hashQueryKeyByOptions","functionalUpdate","QueryCache","MutationCache","focusManager","onlineManager","notifyManager","infiniteQueryBehavior","defaultLogger","QueryClient","constructor","config","queryCache","mutationCache","logger","defaultOptions","queryDefaults","mutationDefaults","mount","unsubscribeFocus","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","isOnline","onOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","call","isFetching","arg1","arg2","filters","fetchStatus","findAll","length","isMutating","fetching","getQueryData","queryKey","_this$queryCache$find","find","state","data","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","options","query","prevData","undefined","parsedOptions","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","batch","getQueryState","_this$queryCache$find2","removeQueries","forEach","remove","resetQueries","arg3","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","revert","promises","cancel","Promise","all","then","catch","invalidateQueries","_ref","_filters$refetchType","invalidate","refetchType","resolve","filter","isDisabled","_options$cancelRefetc","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","fetchQuery","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","push","getQueryDefaults","firstMatchingDefaults","process","env","NODE_ENV","matchingDefaults","error","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"sources":["C:/Users/chich/Project/client/node_modules/react-query/lib/core/queryClient.mjs"],"sourcesContent":["import { hashQueryKey, noop, parseFilterArgs, parseQueryArgs, partialMatchKey, hashQueryKeyByOptions, functionalUpdate } from \"./utils.mjs\";\nimport { QueryCache } from \"./queryCache.mjs\";\nimport { MutationCache } from \"./mutationCache.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.mjs\";\nimport { defaultLogger } from \"./logger.mjs\"; // TYPES\n\n// CLASS\nexport class QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}