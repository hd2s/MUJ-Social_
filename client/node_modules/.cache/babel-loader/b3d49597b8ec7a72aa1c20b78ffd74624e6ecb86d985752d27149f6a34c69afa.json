{"ast":null,"code":"import React from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.mjs\";\nimport { notifyManager } from \"../core/notifyManager.mjs\";\nimport { QueriesObserver } from \"../core/queriesObserver.mjs\";\nimport { useQueryClient } from \"./QueryClientProvider.mjs\";\nimport { useIsRestoring } from \"./isRestoring.mjs\"; // This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\n\nexport function useQueries({\n  queries,\n  context\n}) {\n  const queryClient = useQueryClient({\n    context\n  });\n  const isRestoring = useIsRestoring();\n  const defaultedQueries = React.useMemo(() => queries.map(options => {\n    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';\n    return defaultedOptions;\n  }), [queries, queryClient, isRestoring]);\n  const [observer] = React.useState(() => new QueriesObserver(queryClient, defaultedQueries));\n  const result = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  return result;\n}","map":{"version":3,"names":["React","useSyncExternalStore","notifyManager","QueriesObserver","useQueryClient","useIsRestoring","useQueries","queries","context","queryClient","isRestoring","defaultedQueries","useMemo","map","options","defaultedOptions","defaultQueryOptions","_optimisticResults","observer","useState","result","getOptimisticResult","useCallback","onStoreChange","undefined","subscribe","batchCalls","getCurrentResult","useEffect","setQueries","listeners"],"sources":["C:/Users/chich/Project/client/node_modules/react-query/lib/reactjs/useQueries.mjs"],"sourcesContent":["import React from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.mjs\";\nimport { notifyManager } from \"../core/notifyManager.mjs\";\nimport { QueriesObserver } from \"../core/queriesObserver.mjs\";\nimport { useQueryClient } from \"./QueryClientProvider.mjs\";\nimport { useIsRestoring } from \"./isRestoring.mjs\"; // This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\n\nexport function useQueries({\n  queries,\n  context\n}) {\n  const queryClient = useQueryClient({\n    context\n  });\n  const isRestoring = useIsRestoring();\n  const defaultedQueries = React.useMemo(() => queries.map(options => {\n    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';\n    return defaultedOptions;\n  }), [queries, queryClient, isRestoring]);\n  const [observer] = React.useState(() => new QueriesObserver(queryClient, defaultedQueries));\n  const result = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  return result;\n}"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,oBAAoB,QAAQ,4BAA4B;AACjE,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,cAAc,QAAQ,mBAAmB,CAAC,CAAC;AACpD;;AAEA,OAAO,SAASC,UAAUA,CAAC;EACzBC,OAAO;EACPC;AACF,CAAC,EAAE;EACD,MAAMC,WAAW,GAAGL,cAAc,CAAC;IACjCI;EACF,CAAC,CAAC;EACF,MAAME,WAAW,GAAGL,cAAc,CAAC,CAAC;EACpC,MAAMM,gBAAgB,GAAGX,KAAK,CAACY,OAAO,CAAC,MAAML,OAAO,CAACM,GAAG,CAACC,OAAO,IAAI;IAClE,MAAMC,gBAAgB,GAAGN,WAAW,CAACO,mBAAmB,CAACF,OAAO,CAAC,CAAC,CAAC;;IAEnEC,gBAAgB,CAACE,kBAAkB,GAAGP,WAAW,GAAG,aAAa,GAAG,YAAY;IAChF,OAAOK,gBAAgB;EACzB,CAAC,CAAC,EAAE,CAACR,OAAO,EAAEE,WAAW,EAAEC,WAAW,CAAC,CAAC;EACxC,MAAM,CAACQ,QAAQ,CAAC,GAAGlB,KAAK,CAACmB,QAAQ,CAAC,MAAM,IAAIhB,eAAe,CAACM,WAAW,EAAEE,gBAAgB,CAAC,CAAC;EAC3F,MAAMS,MAAM,GAAGF,QAAQ,CAACG,mBAAmB,CAACV,gBAAgB,CAAC;EAC7DV,oBAAoB,CAACD,KAAK,CAACsB,WAAW,CAACC,aAAa,IAAIb,WAAW,GAAG,MAAMc,SAAS,GAAGN,QAAQ,CAACO,SAAS,CAACvB,aAAa,CAACwB,UAAU,CAACH,aAAa,CAAC,CAAC,EAAE,CAACL,QAAQ,EAAER,WAAW,CAAC,CAAC,EAAE,MAAMQ,QAAQ,CAACS,gBAAgB,CAAC,CAAC,EAAE,MAAMT,QAAQ,CAACS,gBAAgB,CAAC,CAAC,CAAC;EACpP3B,KAAK,CAAC4B,SAAS,CAAC,MAAM;IACpB;IACA;IACAV,QAAQ,CAACW,UAAU,CAAClB,gBAAgB,EAAE;MACpCmB,SAAS,EAAE;IACb,CAAC,CAAC;EACJ,CAAC,EAAE,CAACnB,gBAAgB,EAAEO,QAAQ,CAAC,CAAC;EAChC,OAAOE,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}