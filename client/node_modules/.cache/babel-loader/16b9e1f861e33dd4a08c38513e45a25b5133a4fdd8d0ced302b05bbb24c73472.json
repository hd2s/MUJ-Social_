{"ast":null,"code":"import { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { sleep } from \"./utils.mjs\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\nexport function canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nexport class CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n}\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nexport function createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}","map":{"version":3,"names":["focusManager","onlineManager","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","isFocused","resolve","onSuccess","onError","pause","continueResolve","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","continue"],"sources":["C:/Users/chich/Project/client/node_modules/react-query/lib/core/retryer.mjs"],"sourcesContent":["import { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { sleep } from \"./utils.mjs\";\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nexport function canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nexport class CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nexport function createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}"],"mappings":"AAAA,SAASA,YAAY,QAAQ,oBAAoB;AACjD,SAASC,aAAa,QAAQ,qBAAqB;AACnD,SAASC,KAAK,QAAQ,aAAa;AAEnC,SAASC,iBAAiBA,CAACC,YAAY,EAAE;EACvC,OAAOC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAIF,YAAY,EAAE,KAAK,CAAC;AAClD;AAEA,OAAO,SAASG,QAAQA,CAACC,WAAW,EAAE;EACpC,OAAO,CAACA,WAAW,IAAI,IAAI,GAAGA,WAAW,GAAG,QAAQ,MAAM,QAAQ,GAAGP,aAAa,CAACQ,QAAQ,CAAC,CAAC,GAAG,IAAI;AACtG;AACA,OAAO,MAAMC,cAAc,CAAC;EAC1BC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACC,MAAM,GAAGD,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACC,MAAM;IACvD,IAAI,CAACC,MAAM,GAAGF,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACE,MAAM;EACzD;AAEF;AACA,OAAO,SAASC,gBAAgBA,CAACC,KAAK,EAAE;EACtC,OAAOA,KAAK,YAAYN,cAAc;AACxC;AACA,OAAO,SAASO,aAAaA,CAACC,MAAM,EAAE;EACpC,IAAIC,gBAAgB,GAAG,KAAK;EAC5B,IAAIf,YAAY,GAAG,CAAC;EACpB,IAAIgB,UAAU,GAAG,KAAK;EACtB,IAAIC,UAAU;EACd,IAAIC,cAAc;EAClB,IAAIC,aAAa;EACjB,MAAMC,OAAO,GAAG,IAAIC,OAAO,CAAC,CAACC,YAAY,EAAEC,WAAW,KAAK;IACzDL,cAAc,GAAGI,YAAY;IAC7BH,aAAa,GAAGI,WAAW;EAC7B,CAAC,CAAC;EAEF,MAAMC,MAAM,GAAGC,aAAa,IAAI;IAC9B,IAAI,CAACT,UAAU,EAAE;MACfU,MAAM,CAAC,IAAIpB,cAAc,CAACmB,aAAa,CAAC,CAAC;MACzCX,MAAM,CAACa,KAAK,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGb,MAAM,CAACa,KAAK,CAAC,CAAC;IAChD;EACF,CAAC;EAED,MAAMC,WAAW,GAAGA,CAAA,KAAM;IACxBb,gBAAgB,GAAG,IAAI;EACzB,CAAC;EAED,MAAMc,aAAa,GAAGA,CAAA,KAAM;IAC1Bd,gBAAgB,GAAG,KAAK;EAC1B,CAAC;EAED,MAAMe,WAAW,GAAGA,CAAA,KAAM,CAAClC,YAAY,CAACmC,SAAS,CAAC,CAAC,IAAIjB,MAAM,CAACV,WAAW,KAAK,QAAQ,IAAI,CAACP,aAAa,CAACQ,QAAQ,CAAC,CAAC;EAEnH,MAAM2B,OAAO,GAAGpB,KAAK,IAAI;IACvB,IAAI,CAACI,UAAU,EAAE;MACfA,UAAU,GAAG,IAAI;MACjBF,MAAM,CAACmB,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGnB,MAAM,CAACmB,SAAS,CAACrB,KAAK,CAAC;MAC3DK,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;MAC1CC,cAAc,CAACN,KAAK,CAAC;IACvB;EACF,CAAC;EAED,MAAMc,MAAM,GAAGd,KAAK,IAAI;IACtB,IAAI,CAACI,UAAU,EAAE;MACfA,UAAU,GAAG,IAAI;MACjBF,MAAM,CAACoB,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGpB,MAAM,CAACoB,OAAO,CAACtB,KAAK,CAAC;MACvDK,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;MAC1CE,aAAa,CAACP,KAAK,CAAC;IACtB;EACF,CAAC;EAED,MAAMuB,KAAK,GAAGA,CAAA,KAAM;IAClB,OAAO,IAAId,OAAO,CAACe,eAAe,IAAI;MACpCnB,UAAU,GAAGL,KAAK,IAAI;QACpB,IAAII,UAAU,IAAI,CAACc,WAAW,CAAC,CAAC,EAAE;UAChC,OAAOM,eAAe,CAACxB,KAAK,CAAC;QAC/B;MACF,CAAC;MAEDE,MAAM,CAACuB,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGvB,MAAM,CAACuB,OAAO,CAAC,CAAC;IACpD,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;MACZrB,UAAU,GAAGsB,SAAS;MAEtB,IAAI,CAACvB,UAAU,EAAE;QACfF,MAAM,CAAC0B,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG1B,MAAM,CAAC0B,UAAU,CAAC,CAAC;MAC1D;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,CAAC;;EAGH,MAAMC,GAAG,GAAGA,CAAA,KAAM;IAChB;IACA,IAAIzB,UAAU,EAAE;MACd;IACF;IAEA,IAAI0B,cAAc,CAAC,CAAC;;IAEpB,IAAI;MACFA,cAAc,GAAG5B,MAAM,CAAC6B,EAAE,CAAC,CAAC;IAC9B,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdF,cAAc,GAAGrB,OAAO,CAACK,MAAM,CAACkB,KAAK,CAAC;IACxC;IAEAvB,OAAO,CAACW,OAAO,CAACU,cAAc,CAAC,CAACJ,IAAI,CAACN,OAAO,CAAC,CAACa,KAAK,CAACD,KAAK,IAAI;MAC3D,IAAIE,aAAa,EAAEC,kBAAkB;;MAErC;MACA,IAAI/B,UAAU,EAAE;QACd;MACF,CAAC,CAAC;;MAGF,MAAMgC,KAAK,GAAG,CAACF,aAAa,GAAGhC,MAAM,CAACkC,KAAK,KAAK,IAAI,GAAGF,aAAa,GAAG,CAAC;MACxE,MAAMG,UAAU,GAAG,CAACF,kBAAkB,GAAGjC,MAAM,CAACmC,UAAU,KAAK,IAAI,GAAGF,kBAAkB,GAAGhD,iBAAiB;MAC5G,MAAMmD,KAAK,GAAG,OAAOD,UAAU,KAAK,UAAU,GAAGA,UAAU,CAACjD,YAAY,EAAE4C,KAAK,CAAC,GAAGK,UAAU;MAC7F,MAAME,WAAW,GAAGH,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIhD,YAAY,GAAGgD,KAAK,IAAI,OAAOA,KAAK,KAAK,UAAU,IAAIA,KAAK,CAAChD,YAAY,EAAE4C,KAAK,CAAC;MAEpJ,IAAI7B,gBAAgB,IAAI,CAACoC,WAAW,EAAE;QACpC;QACAzB,MAAM,CAACkB,KAAK,CAAC;QACb;MACF;MAEA5C,YAAY,EAAE,CAAC,CAAC;;MAEhBc,MAAM,CAACsC,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGtC,MAAM,CAACsC,MAAM,CAACpD,YAAY,EAAE4C,KAAK,CAAC,CAAC,CAAC;;MAErE9C,KAAK,CAACoD,KAAK,CAAC,CAAC;MAAA,CACZZ,IAAI,CAAC,MAAM;QACV,IAAIR,WAAW,CAAC,CAAC,EAAE;UACjB,OAAOK,KAAK,CAAC,CAAC;QAChB;MACF,CAAC,CAAC,CAACG,IAAI,CAAC,MAAM;QACZ,IAAIvB,gBAAgB,EAAE;UACpBW,MAAM,CAACkB,KAAK,CAAC;QACf,CAAC,MAAM;UACLH,GAAG,CAAC,CAAC;QACP;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC,CAAC;;EAGH,IAAItC,QAAQ,CAACW,MAAM,CAACV,WAAW,CAAC,EAAE;IAChCqC,GAAG,CAAC,CAAC;EACP,CAAC,MAAM;IACLN,KAAK,CAAC,CAAC,CAACG,IAAI,CAACG,GAAG,CAAC;EACnB;EAEA,OAAO;IACLrB,OAAO;IACPI,MAAM;IACN6B,QAAQ,EAAEA,CAAA,KAAM;MACdpC,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;IAC5C,CAAC;IACDW,WAAW;IACXC;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}