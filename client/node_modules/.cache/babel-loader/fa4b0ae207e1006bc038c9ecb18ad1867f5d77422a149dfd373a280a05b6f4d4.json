{"ast":null,"code":"import { difference, replaceAt } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { QueryObserver } from \"./queryObserver.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nexport class QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n  getCurrentResult() {\n    return this.result;\n  }\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n}","map":{"version":3,"names":["difference","replaceAt","notifyManager","QueryObserver","Subscribable","QueriesObserver","constructor","client","queries","result","observers","observersMap","setQueries","onSubscribe","listeners","length","forEach","observer","subscribe","onUpdate","onUnsubscribe","destroy","notifyOptions","batch","prevObservers","newObserverMatches","findMatchingObservers","match","setOptions","defaultedQueryOptions","newObservers","map","newObserversMap","Object","fromEntries","options","queryHash","newResult","getCurrentResult","hasIndexChange","some","index","hasListeners","notify","getOptimisticResult","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","find","matchedQueryHashes","unmatchedQueries","filter","includes","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","sortMatchesByOrderOfQueries","a","b","indexOf","concat","sort","listener"],"sources":["C:/Users/chich/Project/client/node_modules/react-query/lib/core/queriesObserver.mjs"],"sourcesContent":["import { difference, replaceAt } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { QueryObserver } from \"./queryObserver.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nexport class QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}