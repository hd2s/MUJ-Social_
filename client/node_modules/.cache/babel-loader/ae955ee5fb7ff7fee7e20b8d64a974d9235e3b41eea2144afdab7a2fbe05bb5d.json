{"ast":null,"code":"import { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n\n// CLASS\nexport class Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n  setOptions(options) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    var _this$retryer;\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    var _this$retryer2;\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n  onOnline() {\n    var _this$retryer3;\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n          return undefined;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused'\n          };\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching'\n          };\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n        case 'error':\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return {\n              ...this.revertState\n            };\n          }\n          return {\n            ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case 'setState':\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}","map":{"version":3,"names":["getAbortController","noop","replaceData","timeUntilStale","defaultLogger","notifyManager","isCancelledError","canFetch","createRetryer","Removable","Query","constructor","config","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","queryKey","queryHash","initialState","state","getDefaultState","meta","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_this$retryer","promise","retryer","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_this$retryer3","shouldFetchOnReconnect","addObserver","indexOf","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","scheduleGc","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","Array","isArray","process","env","NODE_ENV","error","abortController","queryFnContext","pageParam","undefined","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","call","isFetchingOptimistic","fn","abort","bind","onSuccess","_this$cache$config$on2","_this$cache$config2","Error","onFail","onPause","onContinue","retry","retryDelay","networkMode","action","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasInitialData","initialDataUpdatedAt","hasData"],"sources":["C:/Users/chich/Project/client/node_modules/react-query/lib/core/query.mjs"],"sourcesContent":["import { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n\n// CLASS\nexport class Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}