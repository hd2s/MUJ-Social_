{"ast":null,"code":"/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"react\"), require(\"use-sync-external-store/shim\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\", \"use-sync-external-store/shim\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).ReactQuery = {}, t.React, t.shim);\n}(this, function (t, e, s) {\n  \"use strict\";\n\n  function r(t) {\n    if (t && t.__esModule) return t;\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (s) {\n      if (\"default\" !== s) {\n        var r = Object.getOwnPropertyDescriptor(t, s);\n        Object.defineProperty(e, s, r.get ? r : {\n          enumerable: !0,\n          get: function () {\n            return t[s];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n  var i = r(e);\n  /**\n     * query-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n  class n {\n    constructor() {\n      this.listeners = [], this.subscribe = this.subscribe.bind(this);\n    }\n    subscribe(t) {\n      return this.listeners.push(t), this.onSubscribe(), () => {\n        this.listeners = this.listeners.filter(e => e !== t), this.onUnsubscribe();\n      };\n    }\n    hasListeners() {\n      return this.listeners.length > 0;\n    }\n    onSubscribe() {}\n    onUnsubscribe() {}\n  }\n  const o = \"undefined\" == typeof window;\n  function a() {}\n  function u(t) {\n    return \"number\" == typeof t && t >= 0 && t !== 1 / 0;\n  }\n  function c(t, e) {\n    return t.filter(t => -1 === e.indexOf(t));\n  }\n  function h(t, e) {\n    return Math.max(t + (e || 0) - Date.now(), 0);\n  }\n  function l(t, e, s) {\n    return Q(t) ? \"function\" == typeof e ? {\n      ...s,\n      queryKey: t,\n      queryFn: e\n    } : {\n      ...e,\n      queryKey: t\n    } : t;\n  }\n  function d(t, e, s) {\n    return Q(t) ? \"function\" == typeof e ? {\n      ...s,\n      mutationKey: t,\n      mutationFn: e\n    } : {\n      ...e,\n      mutationKey: t\n    } : \"function\" == typeof t ? {\n      ...e,\n      mutationFn: t\n    } : {\n      ...t\n    };\n  }\n  function f(t, e, s) {\n    return Q(t) ? [{\n      ...e,\n      queryKey: t\n    }, s] : [t || {}, e];\n  }\n  function p(t, e, s) {\n    return Q(t) ? [{\n      ...e,\n      mutationKey: t\n    }, s] : [t || {}, e];\n  }\n  function y(t, e) {\n    const {\n      type: s = \"all\",\n      exact: r,\n      fetchStatus: i,\n      predicate: n,\n      queryKey: o,\n      stale: a\n    } = t;\n    if (Q(o)) if (r) {\n      if (e.queryHash !== m(o, e.options)) return !1;\n    } else if (!g(e.queryKey, o)) return !1;\n    if (\"all\" !== s) {\n      const t = e.isActive();\n      if (\"active\" === s && !t) return !1;\n      if (\"inactive\" === s && t) return !1;\n    }\n    return (\"boolean\" != typeof a || e.isStale() === a) && (void 0 === i || i === e.state.fetchStatus) && !(n && !n(e));\n  }\n  function v(t, e) {\n    const {\n      exact: s,\n      fetching: r,\n      predicate: i,\n      mutationKey: n\n    } = t;\n    if (Q(n)) {\n      if (!e.options.mutationKey) return !1;\n      if (s) {\n        if (b(e.options.mutationKey) !== b(n)) return !1;\n      } else if (!g(e.options.mutationKey, n)) return !1;\n    }\n    return (\"boolean\" != typeof r || \"loading\" === e.state.status === r) && !(i && !i(e));\n  }\n  function m(t, e) {\n    return ((null == e ? void 0 : e.queryKeyHashFn) || b)(t);\n  }\n  function b(t) {\n    return JSON.stringify(t, (t, e) => S(e) ? Object.keys(e).sort().reduce((t, s) => (t[s] = e[s], t), {}) : e);\n  }\n  function g(t, e) {\n    return O(t, e);\n  }\n  function O(t, e) {\n    return t === e || typeof t == typeof e && !(!t || !e || \"object\" != typeof t || \"object\" != typeof e) && !Object.keys(e).some(s => !O(t[s], e[s]));\n  }\n  function C(t, e) {\n    if (t === e) return t;\n    const s = q(t) && q(e);\n    if (s || S(t) && S(e)) {\n      const r = s ? t.length : Object.keys(t).length,\n        i = s ? e : Object.keys(e),\n        n = i.length,\n        o = s ? [] : {};\n      let a = 0;\n      for (let r = 0; r < n; r++) {\n        const n = s ? r : i[r];\n        o[n] = C(t[n], e[n]), o[n] === t[n] && a++;\n      }\n      return r === n && a === r ? t : o;\n    }\n    return e;\n  }\n  function R(t, e) {\n    if (t && !e || e && !t) return !1;\n    for (const s in t) if (t[s] !== e[s]) return !1;\n    return !0;\n  }\n  function q(t) {\n    return Array.isArray(t) && t.length === Object.keys(t).length;\n  }\n  function S(t) {\n    if (!P(t)) return !1;\n    const e = t.constructor;\n    if (void 0 === e) return !0;\n    const s = e.prototype;\n    return !!P(s) && !!s.hasOwnProperty(\"isPrototypeOf\");\n  }\n  function P(t) {\n    return \"[object Object]\" === Object.prototype.toString.call(t);\n  }\n  function Q(t) {\n    return Array.isArray(t);\n  }\n  function E(t) {\n    return new Promise(e => {\n      setTimeout(e, t);\n    });\n  }\n  function x(t) {\n    E(0).then(t);\n  }\n  function M(t, e, s) {\n    return null != s.isDataEqual && s.isDataEqual(t, e) ? t : \"function\" == typeof s.structuralSharing ? s.structuralSharing(t, e) : !1 !== s.structuralSharing ? C(t, e) : e;\n  }\n  const w = new class extends n {\n    constructor() {\n      super(), this.setup = t => {\n        if (!o && window.addEventListener) {\n          const e = () => t();\n          return window.addEventListener(\"visibilitychange\", e, !1), window.addEventListener(\"focus\", e, !1), () => {\n            window.removeEventListener(\"visibilitychange\", e), window.removeEventListener(\"focus\", e);\n          };\n        }\n      };\n    }\n    onSubscribe() {\n      this.cleanup || this.setEventListener(this.setup);\n    }\n    onUnsubscribe() {\n      var t;\n      this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n    }\n    setEventListener(t) {\n      var e;\n      this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(t => {\n        \"boolean\" == typeof t ? this.setFocused(t) : this.onFocus();\n      });\n    }\n    setFocused(t) {\n      this.focused = t, t && this.onFocus();\n    }\n    onFocus() {\n      this.listeners.forEach(t => {\n        t();\n      });\n    }\n    isFocused() {\n      return \"boolean\" == typeof this.focused ? this.focused : \"undefined\" == typeof document || [void 0, \"visible\", \"prerender\"].includes(document.visibilityState);\n    }\n  }();\n  const F = new class extends n {\n    constructor() {\n      super(), this.setup = t => {\n        if (!o && window.addEventListener) {\n          const e = () => t();\n          return window.addEventListener(\"online\", e, !1), window.addEventListener(\"offline\", e, !1), () => {\n            window.removeEventListener(\"online\", e), window.removeEventListener(\"offline\", e);\n          };\n        }\n      };\n    }\n    onSubscribe() {\n      this.cleanup || this.setEventListener(this.setup);\n    }\n    onUnsubscribe() {\n      var t;\n      this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n    }\n    setEventListener(t) {\n      var e;\n      this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(t => {\n        \"boolean\" == typeof t ? this.setOnline(t) : this.onOnline();\n      });\n    }\n    setOnline(t) {\n      this.online = t, t && this.onOnline();\n    }\n    onOnline() {\n      this.listeners.forEach(t => {\n        t();\n      });\n    }\n    isOnline() {\n      return \"boolean\" == typeof this.online ? this.online : \"undefined\" == typeof navigator || void 0 === navigator.onLine || navigator.onLine;\n    }\n  }();\n  function A(t) {\n    return Math.min(1e3 * 2 ** t, 3e4);\n  }\n  function D(t) {\n    return \"online\" !== (null != t ? t : \"online\") || F.isOnline();\n  }\n  class U {\n    constructor(t) {\n      this.revert = null == t ? void 0 : t.revert, this.silent = null == t ? void 0 : t.silent;\n    }\n  }\n  function I(t) {\n    return t instanceof U;\n  }\n  function T(t) {\n    let e,\n      s,\n      r,\n      i = !1,\n      n = 0,\n      o = !1;\n    const a = new Promise((t, e) => {\n        s = t, r = e;\n      }),\n      u = () => !w.isFocused() || \"always\" !== t.networkMode && !F.isOnline(),\n      c = r => {\n        o || (o = !0, null == t.onSuccess || t.onSuccess(r), null == e || e(), s(r));\n      },\n      h = s => {\n        o || (o = !0, null == t.onError || t.onError(s), null == e || e(), r(s));\n      },\n      l = () => new Promise(s => {\n        e = t => {\n          if (o || !u()) return s(t);\n        }, null == t.onPause || t.onPause();\n      }).then(() => {\n        e = void 0, o || null == t.onContinue || t.onContinue();\n      }),\n      d = () => {\n        if (o) return;\n        let e;\n        try {\n          e = t.fn();\n        } catch (t) {\n          e = Promise.reject(t);\n        }\n        Promise.resolve(e).then(c).catch(e => {\n          var s, r;\n          if (o) return;\n          const a = null != (s = t.retry) ? s : 3,\n            c = null != (r = t.retryDelay) ? r : A,\n            f = \"function\" == typeof c ? c(n, e) : c,\n            p = !0 === a || \"number\" == typeof a && n < a || \"function\" == typeof a && a(n, e);\n          !i && p ? (n++, null == t.onFail || t.onFail(n, e), E(f).then(() => {\n            if (u()) return l();\n          }).then(() => {\n            i ? h(e) : d();\n          })) : h(e);\n        });\n      };\n    return D(t.networkMode) ? d() : l().then(d), {\n      promise: a,\n      cancel: e => {\n        o || (h(new U(e)), null == t.abort || t.abort());\n      },\n      continue: () => {\n        null == e || e();\n      },\n      cancelRetry: () => {\n        i = !0;\n      },\n      continueRetry: () => {\n        i = !1;\n      }\n    };\n  }\n  const K = console;\n  const k = function () {\n    let t = [],\n      e = 0,\n      s = t => {\n        t();\n      },\n      r = t => {\n        t();\n      };\n    const i = r => {\n        e ? t.push(r) : x(() => {\n          s(r);\n        });\n      },\n      n = () => {\n        const e = t;\n        t = [], e.length && x(() => {\n          r(() => {\n            e.forEach(t => {\n              s(t);\n            });\n          });\n        });\n      };\n    return {\n      batch: t => {\n        let s;\n        e++;\n        try {\n          s = t();\n        } finally {\n          e--, e || n();\n        }\n        return s;\n      },\n      batchCalls: t => (...e) => {\n        i(() => {\n          t(...e);\n        });\n      },\n      schedule: i,\n      setNotifyFunction: t => {\n        s = t;\n      },\n      setBatchNotifyFunction: t => {\n        r = t;\n      }\n    };\n  }();\n  class L {\n    destroy() {\n      this.clearGcTimeout();\n    }\n    scheduleGc() {\n      this.clearGcTimeout(), u(this.cacheTime) && (this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime));\n    }\n    updateCacheTime(t) {\n      this.cacheTime = Math.max(this.cacheTime || 0, null != t ? t : o ? 1 / 0 : 3e5);\n    }\n    clearGcTimeout() {\n      this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);\n    }\n  }\n  class j extends L {\n    constructor(t) {\n      super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || K, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || function (t) {\n        const e = \"function\" == typeof t.initialData ? t.initialData() : t.initialData,\n          s = void 0 !== t.initialData ? \"function\" == typeof t.initialDataUpdatedAt ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0,\n          r = void 0 !== e;\n        return {\n          data: e,\n          dataUpdateCount: 0,\n          dataUpdatedAt: r ? null != s ? s : Date.now() : 0,\n          error: null,\n          errorUpdateCount: 0,\n          errorUpdatedAt: 0,\n          fetchFailureCount: 0,\n          fetchMeta: null,\n          isInvalidated: !1,\n          status: r ? \"success\" : \"loading\",\n          fetchStatus: \"idle\"\n        };\n      }(this.options), this.state = this.initialState, this.meta = t.meta;\n    }\n    setOptions(t) {\n      this.options = {\n        ...this.defaultOptions,\n        ...t\n      }, this.meta = null == t ? void 0 : t.meta, this.updateCacheTime(this.options.cacheTime);\n    }\n    optionalRemove() {\n      this.observers.length || \"idle\" !== this.state.fetchStatus || this.cache.remove(this);\n    }\n    setData(t, e) {\n      const s = M(this.state.data, t, this.options);\n      return this.dispatch({\n        data: s,\n        type: \"success\",\n        dataUpdatedAt: null == e ? void 0 : e.updatedAt,\n        manual: null == e ? void 0 : e.manual\n      }), s;\n    }\n    setState(t, e) {\n      this.dispatch({\n        type: \"setState\",\n        state: t,\n        setStateOptions: e\n      });\n    }\n    cancel(t) {\n      var e;\n      const s = this.promise;\n      return null == (e = this.retryer) || e.cancel(t), s ? s.then(a).catch(a) : Promise.resolve();\n    }\n    destroy() {\n      super.destroy(), this.cancel({\n        silent: !0\n      });\n    }\n    reset() {\n      this.destroy(), this.setState(this.initialState);\n    }\n    isActive() {\n      return this.observers.some(t => !1 !== t.options.enabled);\n    }\n    isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n    isStale() {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(t => t.getCurrentResult().isStale);\n    }\n    isStaleByTime(t = 0) {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || !h(this.state.dataUpdatedAt, t);\n    }\n    onFocus() {\n      var t;\n      const e = this.observers.find(t => t.shouldFetchOnWindowFocus());\n      e && e.refetch({\n        cancelRefetch: !1\n      }), null == (t = this.retryer) || t.continue();\n    }\n    onOnline() {\n      var t;\n      const e = this.observers.find(t => t.shouldFetchOnReconnect());\n      e && e.refetch({\n        cancelRefetch: !1\n      }), null == (t = this.retryer) || t.continue();\n    }\n    addObserver(t) {\n      -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer: t\n      }));\n    }\n    removeObserver(t) {\n      -1 !== this.observers.indexOf(t) && (this.observers = this.observers.filter(e => e !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({\n        revert: !0\n      }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer: t\n      }));\n    }\n    getObserversCount() {\n      return this.observers.length;\n    }\n    invalidate() {\n      this.state.isInvalidated || this.dispatch({\n        type: \"invalidate\"\n      });\n    }\n    fetch(t, e) {\n      var s, r;\n      if (\"idle\" !== this.state.fetchStatus) if (this.state.dataUpdatedAt && null != e && e.cancelRefetch) this.cancel({\n        silent: !0\n      });else if (this.promise) {\n        var i;\n        return null == (i = this.retryer) || i.continueRetry(), this.promise;\n      }\n      if (t && this.setOptions(t), !this.options.queryFn) {\n        const t = this.observers.find(t => t.options.queryFn);\n        t && this.setOptions(t.options);\n      }\n      Array.isArray(this.options.queryKey);\n      const n = function () {\n          if (\"function\" == typeof AbortController) return new AbortController();\n        }(),\n        o = {\n          queryKey: this.queryKey,\n          pageParam: void 0,\n          meta: this.meta\n        },\n        a = t => {\n          Object.defineProperty(t, \"signal\", {\n            enumerable: !0,\n            get: () => {\n              if (n) return this.abortSignalConsumed = !0, n.signal;\n            }\n          });\n        };\n      a(o);\n      const u = {\n        fetchOptions: e,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(o)) : Promise.reject(\"Missing queryFn\"),\n        meta: this.meta\n      };\n      var c;\n      (a(u), null == (s = this.options.behavior) || s.onFetch(u), this.revertState = this.state, \"idle\" === this.state.fetchStatus || this.state.fetchMeta !== (null == (r = u.fetchOptions) ? void 0 : r.meta)) && this.dispatch({\n        type: \"fetch\",\n        meta: null == (c = u.fetchOptions) ? void 0 : c.meta\n      });\n      const h = t => {\n        var e, s;\n        (I(t) && t.silent || this.dispatch({\n          type: \"error\",\n          error: t\n        }), I(t)) || null == (e = (s = this.cache.config).onError) || e.call(s, t, this);\n        this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;\n      };\n      return this.retryer = T({\n        fn: u.fetchFn,\n        abort: null == n ? void 0 : n.abort.bind(n),\n        onSuccess: t => {\n          var e, s;\n          void 0 !== t ? (this.setData(t), null == (e = (s = this.cache.config).onSuccess) || e.call(s, t, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1) : h(new Error(\"Query data cannot be undefined\"));\n        },\n        onError: h,\n        onFail: () => {\n          this.dispatch({\n            type: \"failed\"\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: \"pause\"\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: \"continue\"\n          });\n        },\n        retry: u.options.retry,\n        retryDelay: u.options.retryDelay,\n        networkMode: u.options.networkMode\n      }), this.promise = this.retryer.promise, this.promise;\n    }\n    dispatch(t) {\n      this.state = (e => {\n        var s, r;\n        switch (t.type) {\n          case \"failed\":\n            return {\n              ...e,\n              fetchFailureCount: e.fetchFailureCount + 1\n            };\n          case \"pause\":\n            return {\n              ...e,\n              fetchStatus: \"paused\"\n            };\n          case \"continue\":\n            return {\n              ...e,\n              fetchStatus: \"fetching\"\n            };\n          case \"fetch\":\n            return {\n              ...e,\n              fetchFailureCount: 0,\n              fetchMeta: null != (s = t.meta) ? s : null,\n              fetchStatus: D(this.options.networkMode) ? \"fetching\" : \"paused\",\n              ...(!e.dataUpdatedAt && {\n                error: null,\n                status: \"loading\"\n              })\n            };\n          case \"success\":\n            return {\n              ...e,\n              data: t.data,\n              dataUpdateCount: e.dataUpdateCount + 1,\n              dataUpdatedAt: null != (r = t.dataUpdatedAt) ? r : Date.now(),\n              error: null,\n              isInvalidated: !1,\n              status: \"success\",\n              ...(!t.manual && {\n                fetchStatus: \"idle\",\n                fetchFailureCount: 0\n              })\n            };\n          case \"error\":\n            const i = t.error;\n            return I(i) && i.revert && this.revertState ? {\n              ...this.revertState\n            } : {\n              ...e,\n              error: i,\n              errorUpdateCount: e.errorUpdateCount + 1,\n              errorUpdatedAt: Date.now(),\n              fetchFailureCount: e.fetchFailureCount + 1,\n              fetchStatus: \"idle\",\n              status: \"error\"\n            };\n          case \"invalidate\":\n            return {\n              ...e,\n              isInvalidated: !0\n            };\n          case \"setState\":\n            return {\n              ...e,\n              ...t.state\n            };\n        }\n      })(this.state), k.batch(() => {\n        this.observers.forEach(e => {\n          e.onQueryUpdate(t);\n        }), this.cache.notify({\n          query: this,\n          type: \"updated\",\n          action: t\n        });\n      });\n    }\n  }\n  class H extends n {\n    constructor(t) {\n      super(), this.config = t || {}, this.queries = [], this.queriesMap = {};\n    }\n    build(t, e, s) {\n      var r;\n      const i = e.queryKey,\n        n = null != (r = e.queryHash) ? r : m(i, e);\n      let o = this.get(n);\n      return o || (o = new j({\n        cache: this,\n        logger: t.getLogger(),\n        queryKey: i,\n        queryHash: n,\n        options: t.defaultQueryOptions(e),\n        state: s,\n        defaultOptions: t.getQueryDefaults(i),\n        meta: e.meta\n      }), this.add(o)), o;\n    }\n    add(t) {\n      this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({\n        type: \"added\",\n        query: t\n      }));\n    }\n    remove(t) {\n      const e = this.queriesMap[t.queryHash];\n      e && (t.destroy(), this.queries = this.queries.filter(e => e !== t), e === t && delete this.queriesMap[t.queryHash], this.notify({\n        type: \"removed\",\n        query: t\n      }));\n    }\n    clear() {\n      k.batch(() => {\n        this.queries.forEach(t => {\n          this.remove(t);\n        });\n      });\n    }\n    get(t) {\n      return this.queriesMap[t];\n    }\n    getAll() {\n      return this.queries;\n    }\n    find(t, e) {\n      const [s] = f(t, e);\n      return void 0 === s.exact && (s.exact = !0), this.queries.find(t => y(s, t));\n    }\n    findAll(t, e) {\n      const [s] = f(t, e);\n      return Object.keys(s).length > 0 ? this.queries.filter(t => y(s, t)) : this.queries;\n    }\n    notify(t) {\n      k.batch(() => {\n        this.listeners.forEach(e => {\n          e(t);\n        });\n      });\n    }\n    onFocus() {\n      k.batch(() => {\n        this.queries.forEach(t => {\n          t.onFocus();\n        });\n      });\n    }\n    onOnline() {\n      k.batch(() => {\n        this.queries.forEach(t => {\n          t.onOnline();\n        });\n      });\n    }\n  }\n  class N extends L {\n    constructor(t) {\n      super(), this.options = {\n        ...t.defaultOptions,\n        ...t.options\n      }, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || K, this.observers = [], this.state = t.state || B(), this.meta = t.meta, this.updateCacheTime(this.options.cacheTime), this.scheduleGc();\n    }\n    setState(t) {\n      this.dispatch({\n        type: \"setState\",\n        state: t\n      });\n    }\n    addObserver(t) {\n      -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer: t\n      }));\n    }\n    removeObserver(t) {\n      this.observers = this.observers.filter(e => e !== t), this.scheduleGc(), this.mutationCache.notify({\n        type: \"observerRemoved\",\n        mutation: this,\n        observer: t\n      });\n    }\n    optionalRemove() {\n      this.observers.length || (\"loading\" === this.state.status ? this.scheduleGc() : this.mutationCache.remove(this));\n    }\n    continue() {\n      return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();\n    }\n    async execute() {\n      const t = () => {\n          var t;\n          return this.retryer = T({\n            fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject(\"No mutationFn found\"),\n            onFail: () => {\n              this.dispatch({\n                type: \"failed\"\n              });\n            },\n            onPause: () => {\n              this.dispatch({\n                type: \"pause\"\n              });\n            },\n            onContinue: () => {\n              this.dispatch({\n                type: \"continue\"\n              });\n            },\n            retry: null != (t = this.options.retry) ? t : 0,\n            retryDelay: this.options.retryDelay,\n            networkMode: this.options.networkMode\n          }), this.retryer.promise;\n        },\n        e = \"loading\" === this.state.status;\n      try {\n        var s, r, i, n, o, a;\n        if (!e) {\n          var u, c, h, l;\n          this.dispatch({\n            type: \"loading\",\n            variables: this.options.variables\n          }), null == (u = (c = this.mutationCache.config).onMutate) || u.call(c, this.state.variables, this);\n          const t = await (null == (h = (l = this.options).onMutate) ? void 0 : h.call(l, this.state.variables));\n          t !== this.state.context && this.dispatch({\n            type: \"loading\",\n            context: t,\n            variables: this.state.variables\n          });\n        }\n        const d = await t();\n        return null == (s = (r = this.mutationCache.config).onSuccess) || s.call(r, d, this.state.variables, this.state.context, this), await (null == (i = (n = this.options).onSuccess) ? void 0 : i.call(n, d, this.state.variables, this.state.context)), await (null == (o = (a = this.options).onSettled) ? void 0 : o.call(a, d, null, this.state.variables, this.state.context)), this.dispatch({\n          type: \"success\",\n          data: d\n        }), d;\n      } catch (t) {\n        try {\n          var d, f, p, y, v, m;\n          throw null == (d = (f = this.mutationCache.config).onError) || d.call(f, t, this.state.variables, this.state.context, this), await (null == (p = (y = this.options).onError) ? void 0 : p.call(y, t, this.state.variables, this.state.context)), await (null == (v = (m = this.options).onSettled) ? void 0 : v.call(m, void 0, t, this.state.variables, this.state.context)), t;\n        } finally {\n          this.dispatch({\n            type: \"error\",\n            error: t\n          });\n        }\n      }\n    }\n    dispatch(t) {\n      this.state = (e => {\n        switch (t.type) {\n          case \"failed\":\n            return {\n              ...e,\n              failureCount: e.failureCount + 1\n            };\n          case \"pause\":\n            return {\n              ...e,\n              isPaused: !0\n            };\n          case \"continue\":\n            return {\n              ...e,\n              isPaused: !1\n            };\n          case \"loading\":\n            return {\n              ...e,\n              context: t.context,\n              data: void 0,\n              error: null,\n              isPaused: !D(this.options.networkMode),\n              status: \"loading\",\n              variables: t.variables\n            };\n          case \"success\":\n            return {\n              ...e,\n              data: t.data,\n              error: null,\n              status: \"success\",\n              isPaused: !1\n            };\n          case \"error\":\n            return {\n              ...e,\n              data: void 0,\n              error: t.error,\n              failureCount: e.failureCount + 1,\n              isPaused: !1,\n              status: \"error\"\n            };\n          case \"setState\":\n            return {\n              ...e,\n              ...t.state\n            };\n        }\n      })(this.state), k.batch(() => {\n        this.observers.forEach(e => {\n          e.onMutationUpdate(t);\n        }), this.mutationCache.notify({\n          mutation: this,\n          type: \"updated\",\n          action: t\n        });\n      });\n    }\n  }\n  function B() {\n    return {\n      context: void 0,\n      data: void 0,\n      error: null,\n      failureCount: 0,\n      isPaused: !1,\n      status: \"idle\",\n      variables: void 0\n    };\n  }\n  class G extends n {\n    constructor(t) {\n      super(), this.config = t || {}, this.mutations = [], this.mutationId = 0;\n    }\n    build(t, e, s) {\n      const r = new N({\n        mutationCache: this,\n        logger: t.getLogger(),\n        mutationId: ++this.mutationId,\n        options: t.defaultMutationOptions(e),\n        state: s,\n        defaultOptions: e.mutationKey ? t.getMutationDefaults(e.mutationKey) : void 0,\n        meta: e.meta\n      });\n      return this.add(r), r;\n    }\n    add(t) {\n      this.mutations.push(t), this.notify({\n        type: \"added\",\n        mutation: t\n      });\n    }\n    remove(t) {\n      this.mutations = this.mutations.filter(e => e !== t), this.notify({\n        type: \"removed\",\n        mutation: t\n      });\n    }\n    clear() {\n      k.batch(() => {\n        this.mutations.forEach(t => {\n          this.remove(t);\n        });\n      });\n    }\n    getAll() {\n      return this.mutations;\n    }\n    find(t) {\n      return void 0 === t.exact && (t.exact = !0), this.mutations.find(e => v(t, e));\n    }\n    findAll(t) {\n      return this.mutations.filter(e => v(t, e));\n    }\n    notify(t) {\n      k.batch(() => {\n        this.listeners.forEach(e => {\n          e(t);\n        });\n      });\n    }\n    resumePausedMutations() {\n      const t = this.mutations.filter(t => t.state.isPaused);\n      return k.batch(() => t.reduce((t, e) => t.then(() => e.continue().catch(a)), Promise.resolve()));\n    }\n  }\n  function _() {\n    return {\n      onFetch: t => {\n        t.fetchFn = () => {\n          var e, s, r, i, n, o;\n          const a = null == (e = t.fetchOptions) || null == (s = e.meta) ? void 0 : s.refetchPage,\n            u = null == (r = t.fetchOptions) || null == (i = r.meta) ? void 0 : i.fetchMore,\n            c = null == u ? void 0 : u.pageParam,\n            h = \"forward\" === (null == u ? void 0 : u.direction),\n            l = \"backward\" === (null == u ? void 0 : u.direction),\n            d = (null == (n = t.state.data) ? void 0 : n.pages) || [],\n            f = (null == (o = t.state.data) ? void 0 : o.pageParams) || [];\n          let p = f,\n            y = !1;\n          const v = t.options.queryFn || (() => Promise.reject(\"Missing queryFn\")),\n            m = (t, e, s, r) => (p = r ? [e, ...p] : [...p, e], r ? [s, ...t] : [...t, s]),\n            b = (e, s, r, i) => {\n              if (y) return Promise.reject(\"Cancelled\");\n              if (void 0 === r && !s && e.length) return Promise.resolve(e);\n              const n = {\n                queryKey: t.queryKey,\n                pageParam: r,\n                meta: t.meta\n              };\n              var o;\n              o = n, Object.defineProperty(o, \"signal\", {\n                enumerable: !0,\n                get: () => {\n                  var e, s;\n                  return null != (e = t.signal) && e.aborted ? y = !0 : null == (s = t.signal) || s.addEventListener(\"abort\", () => {\n                    y = !0;\n                  }), t.signal;\n                }\n              });\n              const a = v(n);\n              return Promise.resolve(a).then(t => m(e, r, t, i));\n            };\n          let g;\n          if (d.length) {\n            if (h) {\n              const e = void 0 !== c,\n                s = e ? c : W(t.options, d);\n              g = b(d, e, s);\n            } else if (l) {\n              const e = void 0 !== c,\n                s = e ? c : z(t.options, d);\n              g = b(d, e, s, !0);\n            } else {\n              p = [];\n              const e = void 0 === t.options.getNextPageParam;\n              g = !a || !d[0] || a(d[0], 0, d) ? b([], e, f[0]) : Promise.resolve(m([], f[0], d[0]));\n              for (let s = 1; s < d.length; s++) g = g.then(r => {\n                if (!a || !d[s] || a(d[s], s, d)) {\n                  const i = e ? f[s] : W(t.options, r);\n                  return b(r, e, i);\n                }\n                return Promise.resolve(m(r, f[s], d[s]));\n              });\n            }\n          } else g = b([]);\n          return g.then(t => ({\n            pages: t,\n            pageParams: p\n          }));\n        };\n      }\n    };\n  }\n  function W(t, e) {\n    return null == t.getNextPageParam ? void 0 : t.getNextPageParam(e[e.length - 1], e);\n  }\n  function z(t, e) {\n    return null == t.getPreviousPageParam ? void 0 : t.getPreviousPageParam(e[0], e);\n  }\n  function J(t, e) {\n    if (t.getNextPageParam && Array.isArray(e)) {\n      const s = W(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n  function V(t, e) {\n    if (t.getPreviousPageParam && Array.isArray(e)) {\n      const s = z(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n  class X extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.options = e, this.trackedProps = new Set(), this.selectError = null, this.bindMethods(), this.setOptions(e);\n    }\n    bindMethods() {\n      this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);\n    }\n    onSubscribe() {\n      1 === this.listeners.length && (this.currentQuery.addObserver(this), Y(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());\n    }\n    onUnsubscribe() {\n      this.listeners.length || this.destroy();\n    }\n    shouldFetchOnReconnect() {\n      return Z(this.currentQuery, this.options, this.options.refetchOnReconnect);\n    }\n    shouldFetchOnWindowFocus() {\n      return Z(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n    }\n    destroy() {\n      this.listeners = [], this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);\n    }\n    setOptions(t, e) {\n      const s = this.options,\n        r = this.currentQuery;\n      if (this.options = this.client.defaultQueryOptions(t), R(s, this.options) || this.client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.currentQuery,\n        observer: this\n      }), void 0 !== this.options.enabled && \"boolean\" != typeof this.options.enabled) throw new Error(\"Expected enabled to be a boolean\");\n      this.options.queryKey || (this.options.queryKey = s.queryKey), this.updateQuery();\n      const i = this.hasListeners();\n      i && $(this.currentQuery, r, this.options, s) && this.executeFetch(), this.updateResult(e), !i || this.currentQuery === r && this.options.enabled === s.enabled && this.options.staleTime === s.staleTime || this.updateStaleTimeout();\n      const n = this.computeRefetchInterval();\n      !i || this.currentQuery === r && this.options.enabled === s.enabled && n === this.currentRefetchInterval || this.updateRefetchInterval(n);\n    }\n    getOptimisticResult(t) {\n      const e = this.client.getQueryCache().build(this.client, t);\n      return this.createResult(e, t);\n    }\n    getCurrentResult() {\n      return this.currentResult;\n    }\n    trackResult(t) {\n      const e = {};\n      return Object.keys(t).forEach(s => {\n        Object.defineProperty(e, s, {\n          configurable: !1,\n          enumerable: !0,\n          get: () => (this.trackedProps.add(s), t[s])\n        });\n      }), e;\n    }\n    getCurrentQuery() {\n      return this.currentQuery;\n    }\n    remove() {\n      this.client.getQueryCache().remove(this.currentQuery);\n    }\n    refetch({\n      refetchPage: t,\n      ...e\n    } = {}) {\n      return this.fetch({\n        ...e,\n        meta: {\n          refetchPage: t\n        }\n      });\n    }\n    fetchOptimistic(t) {\n      const e = this.client.defaultQueryOptions(t),\n        s = this.client.getQueryCache().build(this.client, e);\n      return s.isFetchingOptimistic = !0, s.fetch().then(() => this.createResult(s, e));\n    }\n    fetch(t) {\n      var e;\n      return this.executeFetch({\n        ...t,\n        cancelRefetch: null == (e = t.cancelRefetch) || e\n      }).then(() => (this.updateResult(), this.currentResult));\n    }\n    executeFetch(t) {\n      this.updateQuery();\n      let e = this.currentQuery.fetch(this.options, t);\n      return null != t && t.throwOnError || (e = e.catch(a)), e;\n    }\n    updateStaleTimeout() {\n      if (this.clearStaleTimeout(), o || this.currentResult.isStale || !u(this.options.staleTime)) return;\n      const t = h(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;\n      this.staleTimeoutId = setTimeout(() => {\n        this.currentResult.isStale || this.updateResult();\n      }, t);\n    }\n    computeRefetchInterval() {\n      var t;\n      return \"function\" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (t = this.options.refetchInterval) && t;\n    }\n    updateRefetchInterval(t) {\n      this.clearRefetchInterval(), this.currentRefetchInterval = t, !o && !1 !== this.options.enabled && u(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval(() => {\n        (this.options.refetchIntervalInBackground || w.isFocused()) && this.executeFetch();\n      }, this.currentRefetchInterval));\n    }\n    updateTimers() {\n      this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());\n    }\n    clearStaleTimeout() {\n      this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);\n    }\n    clearRefetchInterval() {\n      this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);\n    }\n    createResult(t, e) {\n      const s = this.currentQuery,\n        r = this.options,\n        i = this.currentResult,\n        n = this.currentResultState,\n        o = this.currentResultOptions,\n        a = t !== s,\n        u = a ? t.state : this.currentQueryInitialState,\n        c = a ? this.currentResult : this.previousQueryResult,\n        {\n          state: h\n        } = t;\n      let l,\n        {\n          dataUpdatedAt: d,\n          error: f,\n          errorUpdatedAt: p,\n          fetchStatus: y,\n          status: v\n        } = h,\n        m = !1,\n        b = !1;\n      if (e._optimisticResults) {\n        const i = this.hasListeners(),\n          n = !i && Y(t, e),\n          o = i && $(t, s, e, r);\n        (n || o) && (y = D(t.options.networkMode) ? \"fetching\" : \"paused\", d || (v = \"loading\")), \"isRestoring\" === e._optimisticResults && (y = \"idle\");\n      }\n      if (e.keepPreviousData && !h.dataUpdateCount && null != c && c.isSuccess && \"error\" !== v) l = c.data, d = c.dataUpdatedAt, v = c.status, m = !0;else if (e.select && void 0 !== h.data) {\n        if (i && h.data === (null == n ? void 0 : n.data) && e.select === this.selectFn) l = this.selectResult;else try {\n          this.selectFn = e.select, l = e.select(h.data), l = M(null == i ? void 0 : i.data, l, e), this.selectResult = l, this.selectError = null;\n        } catch (t) {\n          this.selectError = t;\n        }\n      } else l = h.data;\n      if (void 0 !== e.placeholderData && void 0 === l && \"loading\" === v) {\n        let t;\n        if (null != i && i.isPlaceholderData && e.placeholderData === (null == o ? void 0 : o.placeholderData)) t = i.data;else if (t = \"function\" == typeof e.placeholderData ? e.placeholderData() : e.placeholderData, e.select && void 0 !== t) try {\n          t = e.select(t), t = M(null == i ? void 0 : i.data, t, e), this.selectError = null;\n        } catch (t) {\n          this.selectError = t;\n        }\n        void 0 !== t && (v = \"success\", l = t, b = !0);\n      }\n      this.selectError && (f = this.selectError, l = this.selectResult, p = Date.now(), v = \"error\");\n      const g = \"fetching\" === y;\n      return {\n        status: v,\n        fetchStatus: y,\n        isLoading: \"loading\" === v,\n        isSuccess: \"success\" === v,\n        isError: \"error\" === v,\n        data: l,\n        dataUpdatedAt: d,\n        error: f,\n        errorUpdatedAt: p,\n        failureCount: h.fetchFailureCount,\n        errorUpdateCount: h.errorUpdateCount,\n        isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,\n        isFetchedAfterMount: h.dataUpdateCount > u.dataUpdateCount || h.errorUpdateCount > u.errorUpdateCount,\n        isFetching: g,\n        isRefetching: g && \"loading\" !== v,\n        isLoadingError: \"error\" === v && 0 === h.dataUpdatedAt,\n        isPaused: \"paused\" === y,\n        isPlaceholderData: b,\n        isPreviousData: m,\n        isRefetchError: \"error\" === v && 0 !== h.dataUpdatedAt,\n        isStale: tt(t, e),\n        refetch: this.refetch,\n        remove: this.remove\n      };\n    }\n    updateResult(t) {\n      const e = this.currentResult,\n        s = this.createResult(this.currentQuery, this.options);\n      if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, R(s, e)) return;\n      this.currentResult = s;\n      const r = {\n        cache: !0\n      };\n      !1 !== (null == t ? void 0 : t.listeners) && (() => {\n        if (!e) return !0;\n        const {\n          notifyOnChangeProps: t\n        } = this.options;\n        if (\"all\" === t || !t && !this.trackedProps.size) return !0;\n        const s = new Set(null != t ? t : this.trackedProps);\n        return this.options.useErrorBoundary && s.add(\"error\"), Object.keys(this.currentResult).some(t => {\n          const r = t;\n          return this.currentResult[r] !== e[r] && s.has(r);\n        });\n      })() && (r.listeners = !0), this.notify({\n        ...r,\n        ...t\n      });\n    }\n    updateQuery() {\n      const t = this.client.getQueryCache().build(this.client, this.options);\n      if (t === this.currentQuery) return;\n      const e = this.currentQuery;\n      this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == e || e.removeObserver(this), t.addObserver(this));\n    }\n    onQueryUpdate(t) {\n      const e = {};\n      \"success\" === t.type ? e.onSuccess = !t.manual : \"error\" !== t.type || I(t.error) || (e.onError = !0), this.updateResult(e), this.hasListeners() && this.updateTimers();\n    }\n    notify(t) {\n      k.batch(() => {\n        var e, s, r, i;\n        if (t.onSuccess) null == (e = (s = this.options).onSuccess) || e.call(s, this.currentResult.data), null == (r = (i = this.options).onSettled) || r.call(i, this.currentResult.data, null);else if (t.onError) {\n          var n, o, a, u;\n          null == (n = (o = this.options).onError) || n.call(o, this.currentResult.error), null == (a = (u = this.options).onSettled) || a.call(u, void 0, this.currentResult.error);\n        }\n        t.listeners && this.listeners.forEach(t => {\n          t(this.currentResult);\n        }), t.cache && this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: \"observerResultsUpdated\"\n        });\n      });\n    }\n  }\n  function Y(t, e) {\n    return function (t, e) {\n      return !(!1 === e.enabled || t.state.dataUpdatedAt || \"error\" === t.state.status && !1 === e.retryOnMount);\n    }(t, e) || t.state.dataUpdatedAt > 0 && Z(t, e, e.refetchOnMount);\n  }\n  function Z(t, e, s) {\n    if (!1 !== e.enabled) {\n      const r = \"function\" == typeof s ? s(t) : s;\n      return \"always\" === r || !1 !== r && tt(t, e);\n    }\n    return !1;\n  }\n  function $(t, e, s, r) {\n    return !1 !== s.enabled && (t !== e || !1 === r.enabled) && (!s.suspense || \"error\" !== t.state.status) && tt(t, s);\n  }\n  function tt(t, e) {\n    return t.isStaleByTime(e.staleTime);\n  }\n  class et extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.queries = [], this.result = [], this.observers = [], this.observersMap = {}, e && this.setQueries(e);\n    }\n    onSubscribe() {\n      1 === this.listeners.length && this.observers.forEach(t => {\n        t.subscribe(e => {\n          this.onUpdate(t, e);\n        });\n      });\n    }\n    onUnsubscribe() {\n      this.listeners.length || this.destroy();\n    }\n    destroy() {\n      this.listeners = [], this.observers.forEach(t => {\n        t.destroy();\n      });\n    }\n    setQueries(t, e) {\n      this.queries = t, k.batch(() => {\n        const t = this.observers,\n          s = this.findMatchingObservers(this.queries);\n        s.forEach(t => t.observer.setOptions(t.defaultedQueryOptions, e));\n        const r = s.map(t => t.observer),\n          i = Object.fromEntries(r.map(t => [t.options.queryHash, t])),\n          n = r.map(t => t.getCurrentResult()),\n          o = r.some((e, s) => e !== t[s]);\n        (t.length !== r.length || o) && (this.observers = r, this.observersMap = i, this.result = n, this.hasListeners() && (c(t, r).forEach(t => {\n          t.destroy();\n        }), c(r, t).forEach(t => {\n          t.subscribe(e => {\n            this.onUpdate(t, e);\n          });\n        }), this.notify()));\n      });\n    }\n    getCurrentResult() {\n      return this.result;\n    }\n    getOptimisticResult(t) {\n      return this.findMatchingObservers(t).map(t => t.observer.getOptimisticResult(t.defaultedQueryOptions));\n    }\n    findMatchingObservers(t) {\n      const e = this.observers,\n        s = t.map(t => this.client.defaultQueryOptions(t)),\n        r = s.flatMap(t => {\n          const s = e.find(e => e.options.queryHash === t.queryHash);\n          return null != s ? [{\n            defaultedQueryOptions: t,\n            observer: s\n          }] : [];\n        }),\n        i = r.map(t => t.defaultedQueryOptions.queryHash),\n        n = s.filter(t => !i.includes(t.queryHash)),\n        o = e.filter(t => !r.some(e => e.observer === t)),\n        a = t => {\n          const e = this.client.defaultQueryOptions(t),\n            s = this.observersMap[e.queryHash];\n          return null != s ? s : new X(this.client, e);\n        },\n        u = n.map((t, e) => {\n          if (t.keepPreviousData) {\n            const s = o[e];\n            if (void 0 !== s) return {\n              defaultedQueryOptions: t,\n              observer: s\n            };\n          }\n          return {\n            defaultedQueryOptions: t,\n            observer: a(t)\n          };\n        });\n      return r.concat(u).sort((t, e) => s.indexOf(t.defaultedQueryOptions) - s.indexOf(e.defaultedQueryOptions));\n    }\n    onUpdate(t, e) {\n      const s = this.observers.indexOf(t);\n      -1 !== s && (this.result = function (t, e, s) {\n        const r = t.slice(0);\n        return r[e] = s, r;\n      }(this.result, s, e), this.notify());\n    }\n    notify() {\n      k.batch(() => {\n        this.listeners.forEach(t => {\n          t(this.result);\n        });\n      });\n    }\n  }\n  class st extends X {\n    constructor(t, e) {\n      super(t, e);\n    }\n    bindMethods() {\n      super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n    }\n    setOptions(t, e) {\n      super.setOptions({\n        ...t,\n        behavior: _()\n      }, e);\n    }\n    getOptimisticResult(t) {\n      return t.behavior = _(), super.getOptimisticResult(t);\n    }\n    fetchNextPage({\n      pageParam: t,\n      ...e\n    } = {}) {\n      return this.fetch({\n        ...e,\n        meta: {\n          fetchMore: {\n            direction: \"forward\",\n            pageParam: t\n          }\n        }\n      });\n    }\n    fetchPreviousPage({\n      pageParam: t,\n      ...e\n    } = {}) {\n      return this.fetch({\n        ...e,\n        meta: {\n          fetchMore: {\n            direction: \"backward\",\n            pageParam: t\n          }\n        }\n      });\n    }\n    createResult(t, e) {\n      var s, r, i, n, o, a;\n      const {\n        state: u\n      } = t;\n      return {\n        ...super.createResult(t, e),\n        fetchNextPage: this.fetchNextPage,\n        fetchPreviousPage: this.fetchPreviousPage,\n        hasNextPage: J(e, null == (s = u.data) ? void 0 : s.pages),\n        hasPreviousPage: V(e, null == (r = u.data) ? void 0 : r.pages),\n        isFetchingNextPage: \"fetching\" === u.fetchStatus && \"forward\" === (null == (i = u.fetchMeta) || null == (n = i.fetchMore) ? void 0 : n.direction),\n        isFetchingPreviousPage: \"fetching\" === u.fetchStatus && \"backward\" === (null == (o = u.fetchMeta) || null == (a = o.fetchMore) ? void 0 : a.direction)\n      };\n    }\n  }\n  class rt extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.setOptions(e), this.bindMethods(), this.updateResult();\n    }\n    bindMethods() {\n      this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);\n    }\n    setOptions(t) {\n      const e = this.options;\n      this.options = this.client.defaultMutationOptions(t), R(e, this.options) || this.client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n    onUnsubscribe() {\n      var t;\n      this.listeners.length || null == (t = this.currentMutation) || t.removeObserver(this);\n    }\n    onMutationUpdate(t) {\n      this.updateResult();\n      const e = {\n        listeners: !0\n      };\n      \"success\" === t.type ? e.onSuccess = !0 : \"error\" === t.type && (e.onError = !0), this.notify(e);\n    }\n    getCurrentResult() {\n      return this.currentResult;\n    }\n    reset() {\n      this.currentMutation = void 0, this.updateResult(), this.notify({\n        listeners: !0\n      });\n    }\n    mutate(t, e) {\n      return this.mutateOptions = e, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, {\n        ...this.options,\n        variables: void 0 !== t ? t : this.options.variables\n      }), this.currentMutation.addObserver(this), this.currentMutation.execute();\n    }\n    updateResult() {\n      const t = this.currentMutation ? this.currentMutation.state : {\n          context: void 0,\n          data: void 0,\n          error: null,\n          failureCount: 0,\n          isPaused: !1,\n          status: \"idle\",\n          variables: void 0\n        },\n        e = {\n          ...t,\n          isLoading: \"loading\" === t.status,\n          isSuccess: \"success\" === t.status,\n          isError: \"error\" === t.status,\n          isIdle: \"idle\" === t.status,\n          mutate: this.mutate,\n          reset: this.reset\n        };\n      this.currentResult = e;\n    }\n    notify(t) {\n      k.batch(() => {\n        var e, s, r, i;\n        if (this.mutateOptions) if (t.onSuccess) null == (e = (s = this.mutateOptions).onSuccess) || e.call(s, this.currentResult.data, this.currentResult.variables, this.currentResult.context), null == (r = (i = this.mutateOptions).onSettled) || r.call(i, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);else if (t.onError) {\n          var n, o, a, u;\n          null == (n = (o = this.mutateOptions).onError) || n.call(o, this.currentResult.error, this.currentResult.variables, this.currentResult.context), null == (a = (u = this.mutateOptions).onSettled) || a.call(u, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n        t.listeners && this.listeners.forEach(t => {\n          t(this.currentResult);\n        });\n      });\n    }\n  }\n  function it(t) {\n    return t.state.isPaused;\n  }\n  function nt(t) {\n    return \"success\" === t.state.status;\n  }\n  function ot(t, e, s) {\n    if (\"object\" != typeof e || null === e) return;\n    const r = t.getMutationCache(),\n      i = t.getQueryCache(),\n      n = e.mutations || [],\n      o = e.queries || [];\n    n.forEach(e => {\n      var i;\n      r.build(t, {\n        ...(null == s || null == (i = s.defaultOptions) ? void 0 : i.mutations),\n        mutationKey: e.mutationKey\n      }, e.state);\n    }), o.forEach(e => {\n      var r;\n      const n = i.get(e.queryHash);\n      n ? n.state.dataUpdatedAt < e.state.dataUpdatedAt && n.setState(e.state) : i.build(t, {\n        ...(null == s || null == (r = s.defaultOptions) ? void 0 : r.queries),\n        queryKey: e.queryKey,\n        queryHash: e.queryHash\n      }, e.state);\n    });\n  }\n  const at = i.createContext(void 0),\n    ut = i.createContext(!1);\n  function ct(t, e) {\n    return t || (e && \"undefined\" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = at), window.ReactQueryClientContext) : at);\n  }\n  const ht = ({\n      context: t\n    } = {}) => {\n      const e = i.useContext(ct(t, i.useContext(ut)));\n      if (!e) throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n      return e;\n    },\n    lt = i.createContext(!1),\n    dt = () => i.useContext(lt),\n    ft = lt.Provider;\n  function pt() {\n    let t = !1;\n    return {\n      clearReset: () => {\n        t = !1;\n      },\n      reset: () => {\n        t = !0;\n      },\n      isReset: () => t\n    };\n  }\n  const yt = i.createContext(pt()),\n    vt = () => i.useContext(yt);\n  function mt(t, e) {\n    return \"function\" == typeof t ? t(...e) : !!t;\n  }\n  function bt(t, e) {\n    const r = ht({\n        context: t.context\n      }),\n      n = dt(),\n      o = vt(),\n      a = r.defaultQueryOptions(t);\n    a._optimisticResults = n ? \"isRestoring\" : \"optimistic\", a.onError && (a.onError = k.batchCalls(a.onError)), a.onSuccess && (a.onSuccess = k.batchCalls(a.onSuccess)), a.onSettled && (a.onSettled = k.batchCalls(a.onSettled)), a.suspense && \"number\" != typeof a.staleTime && (a.staleTime = 1e3), (a.suspense || a.useErrorBoundary) && (o.isReset() || (a.retryOnMount = !1));\n    const [u] = i.useState(() => new e(r, a)),\n      c = u.getOptimisticResult(a);\n    if (s.useSyncExternalStore(i.useCallback(t => n ? () => {} : u.subscribe(k.batchCalls(t)), [u, n]), () => u.getCurrentResult(), () => u.getCurrentResult()), i.useEffect(() => {\n      o.clearReset();\n    }, [o]), i.useEffect(() => {\n      u.setOptions(a, {\n        listeners: !1\n      });\n    }, [a, u]), a.suspense && c.isLoading && c.isFetching && !n) throw u.fetchOptimistic(a).then(({\n      data: t\n    }) => {\n      null == a.onSuccess || a.onSuccess(t), null == a.onSettled || a.onSettled(t, null);\n    }).catch(t => {\n      o.clearReset(), null == a.onError || a.onError(t), null == a.onSettled || a.onSettled(void 0, t);\n    });\n    if (c.isError && !o.isReset() && !c.isFetching && mt(a.useErrorBoundary, [c.error, u.getCurrentQuery()])) throw c.error;\n    return a.notifyOnChangeProps ? c : u.trackResult(c);\n  }\n  function gt(t, e = {}) {\n    const s = ht({\n        context: e.context\n      }),\n      r = i.useRef(e);\n    r.current = e, i.useMemo(() => {\n      t && ot(s, t, r.current);\n    }, [s, t]);\n  }\n  function Ot() {}\n  t.CancelledError = U, t.Hydrate = ({\n    children: t,\n    options: e,\n    state: s\n  }) => (gt(s, e), t), t.InfiniteQueryObserver = st, t.IsRestoringProvider = ft, t.MutationCache = G, t.MutationObserver = rt, t.QueriesObserver = et, t.QueryCache = H, t.QueryClient = class {\n    constructor(t = {}) {\n      this.queryCache = t.queryCache || new H(), this.mutationCache = t.mutationCache || new G(), this.logger = t.logger || K, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];\n    }\n    mount() {\n      this.unsubscribeFocus = w.subscribe(() => {\n        w.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());\n      }), this.unsubscribeOnline = F.subscribe(() => {\n        F.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());\n      });\n    }\n    unmount() {\n      var t, e;\n      null == (t = this.unsubscribeFocus) || t.call(this), null == (e = this.unsubscribeOnline) || e.call(this);\n    }\n    isFetching(t, e) {\n      const [s] = f(t, e);\n      return s.fetchStatus = \"fetching\", this.queryCache.findAll(s).length;\n    }\n    isMutating(t) {\n      return this.mutationCache.findAll({\n        ...t,\n        fetching: !0\n      }).length;\n    }\n    getQueryData(t, e) {\n      var s;\n      return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state.data;\n    }\n    getQueriesData(t) {\n      return this.getQueryCache().findAll(t).map(({\n        queryKey: t,\n        state: e\n      }) => [t, e.data]);\n    }\n    setQueryData(t, e, s) {\n      const r = this.queryCache.find(t),\n        i = function (t, e) {\n          return \"function\" == typeof t ? t(e) : t;\n        }(e, null == r ? void 0 : r.state.data);\n      if (void 0 === i) return;\n      const n = l(t),\n        o = this.defaultQueryOptions(n);\n      return this.queryCache.build(this, o).setData(i, {\n        ...s,\n        manual: !0\n      });\n    }\n    setQueriesData(t, e, s) {\n      return k.batch(() => this.getQueryCache().findAll(t).map(({\n        queryKey: t\n      }) => [t, this.setQueryData(t, e, s)]));\n    }\n    getQueryState(t, e) {\n      var s;\n      return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state;\n    }\n    removeQueries(t, e) {\n      const [s] = f(t, e),\n        r = this.queryCache;\n      k.batch(() => {\n        r.findAll(s).forEach(t => {\n          r.remove(t);\n        });\n      });\n    }\n    resetQueries(t, e, s) {\n      const [r, i] = f(t, e, s),\n        n = this.queryCache,\n        o = {\n          type: \"active\",\n          ...r\n        };\n      return k.batch(() => (n.findAll(r).forEach(t => {\n        t.reset();\n      }), this.refetchQueries(o, i)));\n    }\n    cancelQueries(t, e, s) {\n      const [r, i = {}] = f(t, e, s);\n      void 0 === i.revert && (i.revert = !0);\n      const n = k.batch(() => this.queryCache.findAll(r).map(t => t.cancel(i)));\n      return Promise.all(n).then(a).catch(a);\n    }\n    invalidateQueries(t, e, s) {\n      const [r, i] = f(t, e, s);\n      return k.batch(() => {\n        var t, e;\n        if (this.queryCache.findAll(r).forEach(t => {\n          t.invalidate();\n        }), \"none\" === r.refetchType) return Promise.resolve();\n        const s = {\n          ...r,\n          type: null != (t = null != (e = r.refetchType) ? e : r.type) ? t : \"active\"\n        };\n        return this.refetchQueries(s, i);\n      });\n    }\n    refetchQueries(t, e, s) {\n      const [r, i] = f(t, e, s),\n        n = k.batch(() => this.queryCache.findAll(r).filter(t => !t.isDisabled()).map(t => {\n          var e;\n          return t.fetch(void 0, {\n            ...i,\n            cancelRefetch: null == (e = null == i ? void 0 : i.cancelRefetch) || e,\n            meta: {\n              refetchPage: r.refetchPage\n            }\n          });\n        }));\n      let o = Promise.all(n).then(a);\n      return null != i && i.throwOnError || (o = o.catch(a)), o;\n    }\n    fetchQuery(t, e, s) {\n      const r = l(t, e, s),\n        i = this.defaultQueryOptions(r);\n      void 0 === i.retry && (i.retry = !1);\n      const n = this.queryCache.build(this, i);\n      return n.isStaleByTime(i.staleTime) ? n.fetch(i) : Promise.resolve(n.state.data);\n    }\n    prefetchQuery(t, e, s) {\n      return this.fetchQuery(t, e, s).then(a).catch(a);\n    }\n    fetchInfiniteQuery(t, e, s) {\n      const r = l(t, e, s);\n      return r.behavior = _(), this.fetchQuery(r);\n    }\n    prefetchInfiniteQuery(t, e, s) {\n      return this.fetchInfiniteQuery(t, e, s).then(a).catch(a);\n    }\n    resumePausedMutations() {\n      return this.mutationCache.resumePausedMutations();\n    }\n    getQueryCache() {\n      return this.queryCache;\n    }\n    getMutationCache() {\n      return this.mutationCache;\n    }\n    getLogger() {\n      return this.logger;\n    }\n    getDefaultOptions() {\n      return this.defaultOptions;\n    }\n    setDefaultOptions(t) {\n      this.defaultOptions = t;\n    }\n    setQueryDefaults(t, e) {\n      const s = this.queryDefaults.find(e => b(t) === b(e.queryKey));\n      s ? s.defaultOptions = e : this.queryDefaults.push({\n        queryKey: t,\n        defaultOptions: e\n      });\n    }\n    getQueryDefaults(t) {\n      if (!t) return;\n      const e = this.queryDefaults.find(e => g(t, e.queryKey));\n      return null == e ? void 0 : e.defaultOptions;\n    }\n    setMutationDefaults(t, e) {\n      const s = this.mutationDefaults.find(e => b(t) === b(e.mutationKey));\n      s ? s.defaultOptions = e : this.mutationDefaults.push({\n        mutationKey: t,\n        defaultOptions: e\n      });\n    }\n    getMutationDefaults(t) {\n      if (!t) return;\n      const e = this.mutationDefaults.find(e => g(t, e.mutationKey));\n      return null == e ? void 0 : e.defaultOptions;\n    }\n    defaultQueryOptions(t) {\n      if (null != t && t._defaulted) return t;\n      const e = {\n        ...this.defaultOptions.queries,\n        ...this.getQueryDefaults(null == t ? void 0 : t.queryKey),\n        ...t,\n        _defaulted: !0\n      };\n      return !e.queryHash && e.queryKey && (e.queryHash = m(e.queryKey, e)), void 0 === e.refetchOnReconnect && (e.refetchOnReconnect = \"always\" !== e.networkMode), void 0 === e.useErrorBoundary && (e.useErrorBoundary = !!e.suspense), e;\n    }\n    defaultMutationOptions(t) {\n      return null != t && t._defaulted ? t : {\n        ...this.defaultOptions.mutations,\n        ...this.getMutationDefaults(null == t ? void 0 : t.mutationKey),\n        ...t,\n        _defaulted: !0\n      };\n    }\n    clear() {\n      this.queryCache.clear(), this.mutationCache.clear();\n    }\n  }, t.QueryClientProvider = ({\n    client: t,\n    children: e,\n    context: s,\n    contextSharing: r = !1\n  }) => {\n    i.useEffect(() => (t.mount(), () => {\n      t.unmount();\n    }), [t]);\n    const n = ct(s, r);\n    return i.createElement(ut.Provider, {\n      value: !s && r\n    }, i.createElement(n.Provider, {\n      value: t\n    }, e));\n  }, t.QueryErrorResetBoundary = ({\n    children: t\n  }) => {\n    const [e] = i.useState(() => pt());\n    return i.createElement(yt.Provider, {\n      value: e\n    }, \"function\" == typeof t ? t(e) : t);\n  }, t.QueryObserver = X, t.defaultContext = at, t.dehydrate = function (t, e = {}) {\n    const s = [],\n      r = [];\n    if (!1 !== e.dehydrateMutations) {\n      const r = e.shouldDehydrateMutation || it;\n      t.getMutationCache().getAll().forEach(t => {\n        r(t) && s.push(function (t) {\n          return {\n            mutationKey: t.options.mutationKey,\n            state: t.state\n          };\n        }(t));\n      });\n    }\n    if (!1 !== e.dehydrateQueries) {\n      const s = e.shouldDehydrateQuery || nt;\n      t.getQueryCache().getAll().forEach(t => {\n        s(t) && r.push(function (t) {\n          return {\n            state: t.state,\n            queryKey: t.queryKey,\n            queryHash: t.queryHash\n          };\n        }(t));\n      });\n    }\n    return {\n      mutations: s,\n      queries: r\n    };\n  }, t.focusManager = w, t.hashQueryKey = b, t.hydrate = ot, t.isCancelledError = I, t.isError = function (t) {\n    return t instanceof Error;\n  }, t.notifyManager = k, t.onlineManager = F, t.parseFilterArgs = f, t.parseMutationArgs = d, t.parseMutationFilterArgs = p, t.parseQueryArgs = l, t.useHydrate = gt, t.useInfiniteQuery = function (t, e, s) {\n    return bt(l(t, e, s), st);\n  }, t.useIsFetching = function (t, e, r) {\n    const [n, o = {}] = f(t, e, r),\n      a = ht({\n        context: o.context\n      }),\n      u = a.getQueryCache();\n    return s.useSyncExternalStore(i.useCallback(t => u.subscribe(k.batchCalls(t)), [u]), () => a.isFetching(n), () => a.isFetching(n));\n  }, t.useIsMutating = function (t, e, r) {\n    const [n, o = {}] = p(t, e, r),\n      a = ht({\n        context: o.context\n      }),\n      u = a.getMutationCache();\n    return s.useSyncExternalStore(i.useCallback(t => u.subscribe(k.batchCalls(t)), [u]), () => a.isMutating(n), () => a.isMutating(n));\n  }, t.useIsRestoring = dt, t.useMutation = function (t, e, r) {\n    const n = d(t, e, r),\n      o = ht({\n        context: n.context\n      }),\n      [a] = i.useState(() => new rt(o, n));\n    i.useEffect(() => {\n      a.setOptions(n);\n    }, [a, n]);\n    const u = s.useSyncExternalStore(i.useCallback(t => a.subscribe(k.batchCalls(t)), [a]), () => a.getCurrentResult(), () => a.getCurrentResult()),\n      c = i.useCallback((t, e) => {\n        a.mutate(t, e).catch(Ot);\n      }, [a]);\n    if (u.error && mt(a.options.useErrorBoundary, [u.error])) throw u.error;\n    return {\n      ...u,\n      mutate: c,\n      mutateAsync: u.mutate\n    };\n  }, t.useQueries = function ({\n    queries: t,\n    context: e\n  }) {\n    const r = ht({\n        context: e\n      }),\n      n = dt(),\n      o = i.useMemo(() => t.map(t => {\n        const e = r.defaultQueryOptions(t);\n        return e._optimisticResults = n ? \"isRestoring\" : \"optimistic\", e;\n      }), [t, r, n]),\n      [a] = i.useState(() => new et(r, o)),\n      u = a.getOptimisticResult(o);\n    return s.useSyncExternalStore(i.useCallback(t => n ? () => {} : a.subscribe(k.batchCalls(t)), [a, n]), () => a.getCurrentResult(), () => a.getCurrentResult()), i.useEffect(() => {\n      a.setQueries(o, {\n        listeners: !1\n      });\n    }, [o, a]), u;\n  }, t.useQuery = function (t, e, s) {\n    return bt(l(t, e, s), X);\n  }, t.useQueryClient = ht, t.useQueryErrorResetBoundary = vt, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"names":["n","constructor","listeners","subscribe","bind","t","push","onSubscribe","filter","e","onUnsubscribe","hasListeners","length","o","window","a","u","c","indexOf","h","Math","max","Date","now","l","s","Q","queryKey","queryFn","d","mutationKey","mutationFn","f","p","y","type","exact","r","fetchStatus","i","predicate","stale","queryHash","m","options","g","isActive","isStale","state","v","fetching","b","status","queryKeyHashFn","JSON","stringify","S","Object","keys","sort","reduce","O","some","C","q","R","Array","isArray","P","prototype","hasOwnProperty","toString","call","E","Promise","setTimeout","x","then","M","isDataEqual","structuralSharing","w","setup","addEventListener","listener","removeEventListener","cleanup","setEventListener","setFocused","onFocus","focused","forEach","isFocused","document","includes","visibilityState","F","setOnline","onOnline","online","isOnline","navigator","onLine","A","min","D","U","revert","silent","I","T","shouldPause","networkMode","onSuccess","onError","pause","onPause","onContinue","run","fn","reject","resolve","catch","retry","retryDelay","onFail","promise","cancel","abort","continue","cancelRetry","continueRetry","K","console","k","flush","batch","batchCalls","schedule","setNotifyFunction","setBatchNotifyFunction","L","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","clearTimeout","j","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","initialDataUpdatedAt","data","dataUpdateCount","dataUpdatedAt","error","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchMeta","isInvalidated","meta","remove","setData","dispatch","updatedAt","manual","setState","setStateOptions","retryer","reset","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","shouldFetchOnReconnect","addObserver","notify","query","observer","removeObserver","invalidate","fetch","AbortController","pageParam","defineProperty","enumerable","get","signal","fetchOptions","fetchFn","behavior","onFetch","revertState","config","isFetchingOptimistic","Error","onQueryUpdate","action","H","queries","queriesMap","build","getLogger","defaultQueryOptions","getQueryDefaults","add","clear","getAll","findAll","N","mutationId","mutationCache","B","mutation","execute","executeMutation","variables","onMutate","context","onSettled","failureCount","isPaused","onMutationUpdate","G","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","_","refetchPage","fetchMore","direction","pages","pageParams","buildNewPages","fetchPage","aborted","W","z","getNextPageParam","getPreviousPageParam","J","V","X","client","trackedProps","Set","selectError","bindMethods","currentQuery","Y","executeFetch","updateTimers","Z","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","getQueryCache","updateQuery","$","updateResult","staleTime","updateStaleTimeout","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","configurable","getCurrentQuery","fetchOptimistic","throwOnError","staleTimeoutId","refetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","currentResultState","currentResultOptions","currentQueryInitialState","previousQueryResult","_optimisticResults","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isPlaceholderData","isLoading","isError","isFetched","isFetchedAfterMount","isFetching","isRefetching","isLoadingError","isPreviousData","isRefetchError","tt","notifyOnChangeProps","size","useErrorBoundary","has","retryOnMount","refetchOnMount","suspense","et","result","observersMap","setQueries","onUpdate","findMatchingObservers","defaultedQueryOptions","map","fromEntries","flatMap","concat","slice","st","fetchNextPage","fetchPreviousPage","hasNextPage","hasPreviousPage","isFetchingNextPage","isFetchingPreviousPage","rt","mutate","getMutationCache","currentMutation","mutateOptions","isIdle","it","nt","ot","at","createContext","ut","ct","ReactQueryClientContext","ht","useQueryClient","useContext","lt","dt","useIsRestoring","ft","Provider","pt","clearReset","isReset","yt","vt","useQueryErrorResetBoundary","mt","bt","useState","useSyncExternalStore","useCallback","useEffect","gt","useRef","current","useMemo","Ot","CancelledError","Hydrate","children","InfiniteQueryObserver","IsRestoringProvider","MutationCache","MutationObserver","QueriesObserver","QueryCache","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","isMutating","getQueryData","getQueriesData","setQueryData","setQueriesData","getQueryState","removeQueries","resetQueries","refetchQueries","cancelQueries","all","invalidateQueries","refetchType","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","setMutationDefaults","_defaulted","QueryClientProvider","contextSharing","createElement","value","QueryErrorResetBoundary","QueryObserver","defaultContext","dehydrate","dehydrateMutations","shouldDehydrateMutation","dehydrateQueries","shouldDehydrateQuery","focusManager","hashQueryKey","hydrate","isCancelledError","notifyManager","onlineManager","parseFilterArgs","parseMutationArgs","parseMutationFilterArgs","parseQueryArgs","useHydrate","useInfiniteQuery","useIsFetching","useIsMutating","useMutation","mutateAsync","useQueries","useQuery"],"sources":["C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\query-core\\build\\esm\\index.js","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\QueryClientProvider.tsx","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\isRestoring.tsx","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\QueryErrorResetBoundary.tsx","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\utils.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useBaseQuery.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\Hydrate.tsx","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useMutation.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useInfiniteQuery.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useIsFetching.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useIsMutating.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useQueries.ts","C:\\Users\\chich\\Desktop\\Project\\client\\node_modules\\@tanstack\\react-query\\src\\useQuery.ts"],"sourcesContent":["/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\n\nimport { QueryClient } from '@tanstack/query-core'\nimport { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import * as React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n  MutationFunction,\n  MutationKey,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import {\n  QueryObserver,\n  InfiniteQueryObserver,\n  QueryFunction,\n  QueryKey,\n  parseQueryArgs,\n} from '@tanstack/query-core'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import * as React from 'react'\nimport {\n  QueryKey,\n  notifyManager,\n  parseFilterArgs,\n  QueryFilters,\n} from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  MutationKey,\n  MutationFilters,\n  parseMutationFilterArgs,\n} from '@tanstack/query-core'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  QueryKey,\n  QueryFunction,\n  notifyManager,\n  QueriesObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n","import {\n  parseQueryArgs,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport { DefinedUseQueryResult, UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}